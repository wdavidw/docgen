// Generated by CoffeeScript 1.4.0
var convert_anchor, convert_code, docgen, each, fs, getindent, mecano, parameters, path, unindent;

fs = require('fs');

path = require('path');

mecano = require('mecano');

each = require('each');

parameters = require('parameters');

/*
Find indentation based on the first line containing text
*/


getindent = function(text) {
  var line, _i, _len;
  if (!Array.isArray(text)) {
    text = text.split('\n');
  }
  for (_i = 0, _len = text.length; _i < _len; _i++) {
    line = text[_i];
    if (line.trim()) {
      return /(\s*)/.exec(line)[0];
    }
  }
  return '';
};

/*
Discover indentation in first line and remove it for every other lines
*/


unindent = function(lines) {
  var indent;
  lines = lines.split('\n');
  indent = getindent(lines);
  lines = lines.map(function(line) {
    return line.substr(indent.length);
  });
  return lines.join('\n');
};

/*
Create an anchor from the function name in the title
*/


convert_anchor = function(text) {
  var re_anchor;
  re_anchor = /`([\w.]+)\(/g;
  return text.replace(re_anchor, function(str, code) {
    return "<a name=\"" + code + "\"></a>\n`" + code + "(";
  });
};

convert_code = function(text) {
  var re_code;
  re_code = /\n(\s{4}\s*?\S[\s\S]*?)\n(?!\s)/g;
  return text.replace(re_code, function(str, code) {
    code = code.split('\n').map(function(line) {
      return line.substr(4);
    }).join('\n');
    return "\n\n```javascript\n" + code + "\n```\n\n";
  });
};

/*
docgen(options, callback)
-------------------------

Option is expected to be an object. Only the 
"source" option is required and it may be provided 
as a string or an array. Options include :

*   date
*   source
*   destination
*   jekyll

Provide a source path as an option

    docgen(__filename, funciton(err, md){
      console.log(md);
    });

Jeky example

    docgen({
      jekyll: {
        language: 'en',
        layout: 'page',
        comments: 'false'
        sharing: 'false'
        footer: 'false'
        navigation: 'csv'
        github: 'https://github.com/wdavidw/node-csv-parser'
      }
    })
*/


docgen = module.exports = function(options, callback) {
  var results, _ref;
  results = null;
  if ((_ref = options.date) == null) {
    options.date = docgen.date();
  }
  if (options.destination == null) {
    options.destination = [];
  } else if (!Array.isArray(options.destination)) {
    options.destination = [options.destination];
  }
  return each().files(options.source).parallel(true).on('item', function(source, next) {
    var basename;
    basename = path.basename(source, path.extname(source));
    return fs.readFile(source, 'ascii', function(err, text) {
      var content, docs, k, match, re, title, v, _ref1, _ref2;
      if (err) {
        return callback(err);
      }
      re = /###(.*)\n([\s\S]*?)\n( *)###/g;
      match = re.exec(text);
      _ref1 = docgen.extract(match[2]), title = _ref1.title, content = _ref1.content;
      content = unindent(content);
      content = convert_code(content);
      docs = '---\n';
      docs += "title: \"" + title + "\"\n";
      docs += "date: " + options.date + "\n";
      _ref2 = options.jekyll;
      for (k in _ref2) {
        v = _ref2[k];
        docs += "" + k + ": " + v + "\n";
      }
      docs += '---\n';
      docs += '\n';
      if (content) {
        docs += content;
        docs += '\n';
      }
      while (match = re.exec(text)) {
        if (match[1]) {
          continue;
        }
        match[2] = unindent(match[2]);
        docs += '\n';
        docs += convert_code(convert_anchor(match[2]));
        docs += '\n';
      }
      if (options.destination.length) {
        return each(options.destination).on('item', function(destination, next) {
          destination = "" + destination + "/" + basename + ".md";
          return fs.writeFile(destination, docs, next);
        }).on('both', function(err) {
          return next(err);
        });
      } else {
        if (!results) {
          results = [];
        }
        results.push(docs);
        return next();
      }
    });
  }).on('both', function(err, count) {
    if (err) {
      return callback(err);
    }
    if (count === 0) {
      return callback(new Error("Invalid source " + (JSON.stringify(options.source))));
    }
    return callback(null, results);
  });
};

docgen.extract = function(text) {
  var match;
  match = /(.*\n)?(.+)\n={3,}([\s\S]*)/g.exec(text);
  return {
    title: match[2].trim(),
    content: match[3].trim()
  };
};

docgen.date = function() {
  return (new Date).toISOString();
};
